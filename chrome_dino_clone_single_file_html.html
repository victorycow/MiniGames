<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Chrome Dino — Minimal Clone (v1.4)</title>
  <style>
    :root { --bg: #f7f7f7; --fg: #222; --muted: #8a8a8a; }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--fg); font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif; }
    .wrap { position: relative; height: 100%; display: grid; place-items: center; padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left); }

    canvas { image-rendering: pixelated; background: linear-gradient(#ffffff, #f4f4f4); border: 2px solid #d9d9d9; border-radius: 16px; box-shadow: 0 20px 40px rgba(0,0,0,.08); width: min(960px, 96vw); height: auto; aspect-ratio: 32 / 9; touch-action: manipulation; }

    .hud { position: absolute; inset: 0; pointer-events: none; display: grid; place-items: start center; }
    .score { position: absolute; top: 10px; right: 14px; font-weight: 700; letter-spacing: 1px; }
    .score small { color: var(--muted); font-weight: 600; margin-left: 10px; }
    .banner { position: absolute; inset: 0; display: grid; place-items: center; text-align: center; }
    .card { background: #fff; border: 1px solid #e6e6e6; border-radius: 14px; padding: 18px 20px; box-shadow: 0 10px 24px rgba(0,0,0,.06); }
    .card h1 { margin: 0 0 6px; font-size: 18px; }
    .card p { margin: 0; color: #555; }
    .hint { position: absolute; bottom: 8px; left: 50%; transform: translateX(-50%); color:#666; font-size:12px; }

    .controls { position: absolute; left: 0; right: 0; bottom: 10px; display: none; gap: 10px; justify-content: center; pointer-events: auto; }
    .controls button { pointer-events: auto; border: none; background: #111; color: #fff; font-weight: 700; padding: 12px 16px; border-radius: 14px; box-shadow: 0 6px 16px rgba(0,0,0,.15); }
    .controls button:active { transform: translateY(1px); }
    @media (max-width: 820px) { .controls { display: flex; } }

    .test { position: absolute; top: 8px; left: 8px; background: #111; color:#fff; border-radius: 10px; padding: 8px 10px; font: 12px/1.3 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space: pre; pointer-events:none; opacity:.92; display:none; }
    .test.ok { background:#0a7a2f; }
    .test.fail { background:#9b1c1c; }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="960" height="270" aria-label="Chrome Dino Clone Game"></canvas>
    <div class="hud" aria-hidden="true">
      <div class="score" id="score">00000 <small id="hiscore">HI 00000</small></div>
      <div class="banner" id="banner">
        <div class="card">
          <h1>크롬 다이노 🦖</h1>
          <p>스페이스/↑: 점프 · ↓: 숙이기 · P: 일시정지 · R: 재시작</p>
          <p style="margin-top:8px;color:#888">모바일은 아래 버튼 사용 · 캔버스 탭으로 시작</p>
        </div>
      </div>
      <div class="hint">H: 히트박스 · O: 테스트 로그 보기</div>
      <div class="test" id="test"></div>
    </div>
    <div class="controls">
      <button id="jumpBtn" type="button">점프</button>
      <button id="duckBtn" type="button">숙이기</button>
    </div>
  </div>

  <script>
  // Chrome Dino minimal clone with difficulty scaling, mobile restart UX, and built-in self-tests.
  (() => {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;

    const scoreEl = document.getElementById('score');
    const hiEl = document.getElementById('hiscore');
    const banner = document.getElementById('banner');
    const testEl = document.getElementById('test');

    const W = canvas.width;  // 960
    const H = canvas.height; // 270
    const GROUND_Y = Math.floor(H * 0.78); // ~210

    // Physics tuned: short tap = hop, hold = clear tall cactus
    const PHY = { gravity: 0.62, lowGrav: 0.22, minJumpVy: -10.6, jumpCutVy: -3.0, holdTime: 240 };

    // Difficulty model
    const DIFF = { minGapFloor: 520, maxGapFloor: 800 };
    function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
    function difficultyAt(s){
      // s: score
      const speed = 6 + Math.min(6.5, s / 220); // grows with score
      const minGap = Math.max(950 - speed*30 - s*0.05, DIFF.minGapFloor);
      const maxGap = Math.max(1600 - speed*18 - s*0.04, DIFF.maxGapFloor);
      const pteroProb = clamp(0.18 + s*0.00012, 0.18, 0.55); // probability of flying obstacle
      const doubleChance = clamp(0.10 + s*0.00008, 0.10, 0.40);
      const tripleChance = clamp(-0.02 + s*0.00005, 0.00, 0.18);
      const clusterGapMin = Math.max(28, 44 - Math.floor(s*0.004));
      const clusterGapMax = clusterGapMin + 14;
      const lowAltBias = clamp(0.25 + s*0.00010, 0.25, 0.65); // duck-required ptero more often later
      return { speed, minGap, maxGap, pteroProb, doubleChance, tripleChance, clusterGapMin, clusterGapMax, lowAltBias };
    }
    let curDiff = difficultyAt(0);

    // Game state
    let state = 'ready'; // 'ready' | 'running' | 'gameover' | 'paused'
    let last = performance.now();
    let time = 0;
    let showHit = false;

    // Score
    let distance = 0; // for score
    let score = 0;
    let hi = Number(localStorage.getItem('dino.hi') || 0);

    // Input
    const keys = new Set();
    let jumpHeldMs = 0; // 0=not holding; increases while held up to holdTime

    // Entities
    const clouds = [];
    const groundSegs = [];
    const obstacles = [];

    // Dino
    const dino = { x: 64, y: 0, w: 46, h: 50, vy: 0, onGround: true, duck: false, anim: 0 };

    function reset() {
      state = 'ready';
      banner.style.display = '';
      time = 0; distance = 0; score = 0; jumpHeldMs = 0;
      obstacles.length = 0; clouds.length = 0; groundSegs.length = 0;
      dino.w = 46; dino.h = 50; dino.vy = 0; dino.onGround = true; dino.duck = false;
      dino.y = GROUND_Y - dino.h;
      // Clouds
      for (let i = 0; i < 4; i++) clouds.push({ x: Math.random() * W, y: 20 + Math.random()*80, s: 0.2 + Math.random()*0.5 });
      // Ground segments (repeat pattern)
      for (let x = 0; x < W + 200; x += 40) groundSegs.push({ x, y: GROUND_Y + (Math.random() < 0.05 ? 1 : 0) });
      nextSpawn = 1000; dayNight.t = 0; dayNight.isNight = false;
      curDiff = difficultyAt(0);
    }

    // Day/Night cycle
    const dayNight = { t: 0, isNight: false };
    function toggleDayNight() {
      dayNight.isNight = !dayNight.isNight;
      document.documentElement.style.setProperty('--bg', dayNight.isNight ? '#0c0f14' : '#f7f7f7');
      document.documentElement.style.setProperty('--fg', dayNight.isNight ? '#f0f6ff' : '#222');
    }

    function randInt(a, b) { return (a + Math.floor(Math.random() * (b - a + 1))); }

    function spawnObstacle() {
      // Choose cactus or ptero based on difficulty
      const usePtero = curDiff.speed > 8 && Math.random() < curDiff.pteroProb;
      if (usePtero) {
        // Weighted altitude: low (duck), mid, high — later scores bias to low
        const alts = [GROUND_Y - 40, GROUND_Y - 70, GROUND_Y - 100];
        const r = Math.random();
        const y = r < curDiff.lowAltBias ? alts[0] : (r < (curDiff.lowAltBias + 0.25) ? alts[1] : alts[2]);
        obstacles.push({ kind: 'p', x: W + 40, y, w: 52, h: 36, flap: 0 });
      } else {
        const kind = randInt(0,2); // 0 small, 1 medium, 2 tall
        const w = [18, 26, 34][kind];
        const h = [38, 50, 64][kind];
        // Choose cluster count with increasing chance
        let count = 1;
        if (Math.random() < curDiff.doubleChance) count = 2;
        if (Math.random() < curDiff.tripleChance) count = 3;
        const gap = randInt(curDiff.clusterGapMin, curDiff.clusterGapMax);
        for (let i = 0; i < count; i++) obstacles.push({ kind: 'c', x: W + 40 + i*(w+gap), y: GROUND_Y - h, w, h });
      }
    }

    let nextSpawn = 800; // ms until next spawn

    function ensureRunningUI(){ if (state === 'running' && banner.style.display !== 'none') banner.style.display = 'none'; }

    function update(dt) {
      ensureRunningUI();
      if (state !== 'running') return;
      time += dt;

      // Update difficulty and speed from score
      curDiff = difficultyAt(score);
      const speed = curDiff.speed;

      // Score increases with distance and speed
      distance += dt * speed * 60; // frame-rate independent distance
      score = Math.floor(distance * 0.08);
      scoreEl.firstChild.nodeValue = String(score).padStart(5, '0');
      hiEl.textContent = 'HI ' + String(Math.max(hi, score)).padStart(5, '0');

      // Day/Night toggle every ~1500 score
      dayNight.t += dt * speed;
      if (score > 0 && score % 1500 === 0 && Math.floor((score-1)/1500) !== Math.floor(score/1500)) toggleDayNight();

      // Clouds drift
      for (const c of clouds) { c.x -= (0.3 + c.s) * dt * 60; if (c.x < -60) { c.x = W + Math.random()*120; c.y = 20 + Math.random()*80; c.s = 0.2 + Math.random()*0.5; } }

      // Ground scroll
      for (const g of groundSegs) { g.x -= speed * dt * 60; if (g.x < -40) { g.x += W + 80; g.y = GROUND_Y + (Math.random() < 0.05 ? 1 : 0); } }

      // Spawn logic (gap shortens as score rises)
      nextSpawn -= dt*1000;
      if (nextSpawn <= 0) { spawnObstacle(); nextSpawn = randInt(curDiff.minGap, curDiff.maxGap); }

      // Obstacles move
      for (const ob of obstacles) { ob.x -= speed * dt * 60; if (ob.kind === 'p') ob.flap += dt * 10; }
      while (obstacles.length && obstacles[0].x + obstacles[0].w < -8) obstacles.shift();

      // Dino physics
      dino.vy += (dino.onGround ? 0 : (jumpHeldMs > 0 && jumpHeldMs < PHY.holdTime ? PHY.lowGrav : PHY.gravity)) * 60 * dt;
      dino.y += dino.vy * dt * 60;
      if (dino.y >= GROUND_Y - dino.h) { dino.y = GROUND_Y - dino.h; dino.vy = 0; if (!dino.onGround) jumpHeldMs = 0; dino.onGround = true; } else { dino.onGround = false; }
      if (dino.duck && dino.onGround) dino.h = 34; else dino.h = 50; if (dino.onGround) dino.y = GROUND_Y - dino.h;
      if (dino.onGround) dino.anim += dt * (curDiff.speed*0.5);

      // Collisions (AABB)
      for (const ob of obstacles) {
        const ax = dino.x + 6; const ay = dino.y + 4; const aw = dino.w - 12; const ah = dino.h - 8;
        const bx = ob.x; const by = ob.y; const bw = ob.w; const bh = ob.h;
        if (ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by) { gameOver(); break; }
      }
    }

    function draw() {
      ctx.fillStyle = dayNight.isNight ? '#0c0f14' : '#ffffff'; ctx.fillRect(0, 0, W, H);
      ctx.save(); ctx.globalAlpha = 0.08; ctx.fillStyle = dayNight.isNight ? '#cde0ff' : '#ffbf47'; ctx.beginPath(); ctx.arc(60, 46, 18, 0, Math.PI*2); ctx.fill(); ctx.restore();
      ctx.fillStyle = dayNight.isNight ? '#c6d4e7' : '#d0d0d0'; for (const c of clouds) drawCloud(c.x, c.y, 22);
      ctx.strokeStyle = dayNight.isNight ? '#6b7280' : '#9e9e9e'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(0, GROUND_Y+1); ctx.lineTo(W, GROUND_Y+1); ctx.stroke();
      ctx.fillStyle = dayNight.isNight ? '#4b5563' : '#bdbdbd'; for (const g of groundSegs) ctx.fillRect(g.x, g.y+2, 18, 2);
      for (const ob of obstacles) { if (ob.kind === 'c') drawCactus(ob.x, ob.y, ob.w, ob.h); else drawPtero(ob.x, ob.y, ob.w, ob.h, ob.flap); if (showHit) drawHitbox(ob.x, ob.y, ob.w, ob.h); }
      drawDino(dino); if (showHit) drawHitbox(dino.x+6, dino.y+4, dino.w-12, dino.h-8);
    }

    function drawCloud(x, y, r) { ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.arc(x+20, y-8, r*0.8, 0, Math.PI*2); ctx.arc(x-18, y-6, r*0.7, 0, Math.PI*2); ctx.fill(); }
    function drawCactus(x, y, w, h) { ctx.fillStyle = dayNight.isNight ? '#8cc08c' : '#2f7d32'; ctx.fillRect(Math.floor(x), Math.floor(y), w, h); ctx.fillRect(Math.floor(x - w*0.4), Math.floor(y + h*0.35), Math.floor(w*0.4), Math.floor(h*0.18)); ctx.fillRect(Math.floor(x + w), Math.floor(y + h*0.5), Math.floor(w*0.4), Math.floor(h*0.18)); }
    function drawPtero(x, y, w, h, flap) { const midY = y + h*0.5; ctx.fillStyle = dayNight.isNight ? '#e5e7eb' : '#333'; ctx.beginPath(); ctx.moveTo(x, midY); ctx.lineTo(x + w*0.4, y + (Math.sin(flap)*6)); ctx.lineTo(x + w, midY); ctx.lineTo(x + w*0.6, y + h); ctx.closePath(); ctx.fill(); ctx.fillRect(x-8, midY-6, 10, 10); }
    function drawDino(d) { const leg = Math.floor(d.anim)%2; const color = dayNight.isNight ? '#e5e7eb' : '#222'; ctx.fillStyle = color; ctx.fillRect(d.x, d.y+6, 40, 30); ctx.fillRect(d.x+28, d.y-4, 24, 20); ctx.fillRect(d.x-8, d.y+18, 10, 8); if (d.onGround && !d.duck) { ctx.fillRect(d.x+6, d.y+36, 10, 14); ctx.fillRect(d.x+24, d.y+36, 10, 14); if (leg===0) ctx.clearRect(d.x+6, d.y+36, 10, 6); else ctx.clearRect(d.x+24, d.y+36, 10, 6); } else if (d.duck && d.onGround) { ctx.fillRect(d.x+10, d.y+24, 32, 18); } else { ctx.fillRect(d.x+10, d.y+38, 24, 10); } ctx.fillStyle = dayNight.isNight ? '#0c0f14' : '#fff'; ctx.fillRect(d.x+44, d.y+2, 4, 4); ctx.fillStyle = color; ctx.fillRect(d.x+46, d.y+4, 2, 2); }
    function drawHitbox(x,y,w,h) { ctx.save(); ctx.globalAlpha = 0.3; ctx.fillStyle = '#ef4444'; ctx.fillRect(Math.floor(x), Math.floor(y), Math.floor(w), Math.floor(h)); ctx.restore(); }

    function gameOver() { state = 'gameover'; banner.style.display = ''; if (score > hi) { hi = score; localStorage.setItem('dino.hi', String(hi)); } showCenterMessage('Game Over', 'R: 재시작 · 스페이스: 다시 시작'); }
    function startGame() { if (state === 'running') return; banner.style.display = 'none'; if (state === 'gameover') reset(); state = 'running'; ensureRunningUI(); setTimeout(ensureRunningUI, 0); }
    function showCenterMessage(title, sub) { banner.innerHTML = `<div class="card"><h1>${title}</h1><p>${sub}</p></div>`; }
    function maybeStart(){ if (state === 'ready' || state === 'gameover') { startGame(); return true; } return false; }

    function jump() { if (state !== 'running') return; if (dino.onGround) { dino.vy = PHY.minJumpVy; dino.onGround = false; jumpHeldMs = 1; } }
    function duck(on) { if (on && maybeStart()) return; if (state !== 'running') return; dino.duck = on; }
    function jumpCut(){ if (state !== 'running') return; if (!dino.onGround){ if (dino.vy < PHY.jumpCutVy) dino.vy = PHY.jumpCutVy; jumpHeldMs = PHY.holdTime; } }

    // Input handlers
    window.addEventListener('keydown', (e) => {
      if (['Space','ArrowUp','ArrowDown','KeyP','KeyH','KeyR','KeyO'].includes(e.code)) e.preventDefault();
      if (e.code === 'Space' || e.code === 'ArrowUp') { if (maybeStart()) { keys.add('jump'); return; } if (!keys.has('jump')) jump(); keys.add('jump'); }
      if (e.code === 'ArrowDown') { if (maybeStart()) { keys.add('duck'); return; } duck(true); keys.add('duck'); }
      if (e.code === 'KeyP') { if (state==='running'){ state='paused'; showCenterMessage('일시정지', 'P: 계속 · R: 재시작'); banner.style.display=''; } else if (state==='paused'){ state='running'; banner.style.display='none'; } }
      if (e.code === 'KeyH') { showHit = !showHit; }
      if (e.code === 'KeyR') { reset(); showCenterMessage('준비', '스페이스/↑: 시작'); }
      if (e.code === 'KeyO') { toggleTests(); }
    });
    window.addEventListener('keyup', (e) => { if (e.code === 'Space' || e.code === 'ArrowUp') { keys.delete('jump'); if (dino.vy < PHY.jumpCutVy) dino.vy = PHY.jumpCutVy; jumpHeldMs = PHY.holdTime; } if (e.code === 'ArrowDown') { keys.delete('duck'); duck(false); } });

    // Click / touch on canvas to jump or start
    canvas.addEventListener('mousedown', () => { if (!maybeStart()) jump(); });
    canvas.addEventListener('mouseup', () => jumpCut());
    canvas.addEventListener('touchstart', (e) => { if (!maybeStart()) jump(); e.preventDefault(); }, { passive:false });
    canvas.addEventListener('touchend', () => jumpCut(), { passive:true });

    // On-screen buttons (mobile)
    const jumpBtn = document.getElementById('jumpBtn');
    const duckBtn = document.getElementById('duckBtn');
    jumpBtn.addEventListener('pointerdown', () => { if (!maybeStart()) jump(); });
    jumpBtn.addEventListener('pointerup',   () => jumpCut());
    jumpBtn.addEventListener('pointercancel', () => jumpCut());
    duckBtn.addEventListener('pointerdown', () => { if (!maybeStart()) duck(true); });
    duckBtn.addEventListener('pointerup',   () => duck(false));
    duckBtn.addEventListener('pointercancel', () => duck(false));

    // Main loop
    let lastRAF = null;
    function loop(now) { const dt = Math.min(0.05, (now - last) / 1000); last = now; if (state === 'running') { if (keys.has('jump') && !dino.onGround && jumpHeldMs > 0 && jumpHeldMs < PHY.holdTime) jumpHeldMs += dt*1000; update(dt); } draw(); lastRAF = requestAnimationFrame(loop); }

    reset();
    showCenterMessage('시작하려면 스페이스/↑ 또는 탭', '장애물을 피해 최대 점수를 노리세요');
    requestAnimationFrame((t)=>{ last = t; loop(t); });

    // ------------------- Built-in Test Suite -------------------
    function toggleTests(){ testEl.style.display = testEl.style.display === 'none' ? 'block' : 'none'; }
    function runTests() {
      const out = []; let fails = 0; function test(name, fn){ try { const ok = fn(); out.push((ok? '✔':'✘') + ' ' + name); if(!ok) fails++; } catch(e){ out.push('✘ ' + name + ' — ERR: ' + e.message); fails++; } }

      // Existing tests (do not change)
      test('no stray $1 reference', () => typeof $1 === 'undefined');
      const prevState = state; reset(); state = 'running';
      test('jump() sets vy to minJumpVy', () => { const wasGround = dino.onGround; jump(); return wasGround && dino.vy === PHY.minJumpVy && !dino.onGround; });
      test('jumpCut() caps vy to jumpCutVy when rising', () => { dino.onGround = false; dino.vy = -12; jumpCut(); return Math.abs(dino.vy - PHY.jumpCutVy) < 1e-6; });
      test('spawnObstacle() creates obstacle(s)', () => { const n0 = obstacles.length; spawnObstacle(); return obstacles.length > n0; });
      test('holding jump uses lowGrav', () => { dino.onGround = false; dino.vy = -6; jumpHeldMs = 1; const vy0 = dino.vy; const vyLow = vyAfter(0.016, true); dino.vy = vy0; const vyHigh = vyAfter(0.016, false); return (vyLow - vy0) < (vyHigh - vy0); });
      test('startGame hides banner when running', () => { state='gameover'; banner.style.display=''; startGame(); return state==='running' && banner.style.display==='none'; });
      test('maybeStart from ready hides banner', () => { reset(); banner.style.display=''; const started = maybeStart(); return started && state==='running' && banner.style.display==='none'; });

      // New tests for difficulty scaling
      test('difficulty speed increases with score', () => { const a=difficultyAt(0).speed, b=difficultyAt(3000).speed; return b>a; });
      test('spawn gaps shrink with score (minGap)', () => { const a=difficultyAt(0).minGap, b=difficultyAt(4000).minGap; return a>b; });
      test('ptero probability increases with score', () => { const a=difficultyAt(0).pteroProb, b=difficultyAt(4000).pteroProb; return b>a; });
      test('gap floors respected', () => { const d=difficultyAt(99999); return d.minGap >= DIFF.minGapFloor && d.maxGap >= DIFF.maxGapFloor; });
      test('cluster gap sane and ordered', () => { const d=difficultyAt(5000); return d.clusterGapMin >= 24 && d.clusterGapMax > d.clusterGapMin; });

      function vyAfter(dt, holding){ const g = holding ? PHY.lowGrav : PHY.gravity; return dino.vy + g * 60 * dt; }

      if (fails === 0) { testEl.className = 'test ok'; } else { testEl.className = 'test fail'; }
      testEl.textContent = out.join('\n'); testEl.style.display = (location.hash === '#test') ? 'block' : 'none'; if (location.hash === '#test') console.log(out.join('\n'));
      state = prevState;
    }
    runTests();

  })();
  </script>
</body>
</html>
