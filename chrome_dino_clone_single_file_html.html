<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Chrome Dino — Minimal Clone (v1.2)</title>
  <style>
    :root {
      --bg: #f7f7f7;
      --fg: #222;
      --muted: #8a8a8a;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--fg); font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif; }
    .wrap { position: relative; height: 100%; display: grid; place-items: center; padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left); }

    canvas {
      image-rendering: pixelated;
      background: linear-gradient(#ffffff, #f4f4f4);
      border: 2px solid #d9d9d9; border-radius: 16px; box-shadow: 0 20px 40px rgba(0,0,0,.08);
      width: min(960px, 96vw); height: auto; aspect-ratio: 32 / 9;
      touch-action: manipulation;
    }

    .hud { position: absolute; inset: 0; pointer-events: none; display: grid; place-items: start center; }
    .score { position: absolute; top: 10px; right: 14px; font-weight: 700; letter-spacing: 1px; }
    .score small { color: var(--muted); font-weight: 600; margin-left: 10px; }
    .banner { position: absolute; inset: 0; display: grid; place-items: center; text-align: center; }
    .card { background: #fff; border: 1px solid #e6e6e6; border-radius: 14px; padding: 18px 20px; box-shadow: 0 10px 24px rgba(0,0,0,.06); }
    .card h1 { margin: 0 0 6px; font-size: 18px; }
    .card p { margin: 0; color: #555; }
    .hint { position: absolute; bottom: 8px; left: 50%; transform: translateX(-50%); color:#666; font-size:12px; }

    .controls { position: absolute; left: 0; right: 0; bottom: 10px; display: none; gap: 10px; justify-content: center; pointer-events: auto; }
    .controls button { pointer-events: auto; border: none; background: #111; color: #fff; font-weight: 700; padding: 12px 16px; border-radius: 14px; box-shadow: 0 6px 16px rgba(0,0,0,.15); }
    .controls button:active { transform: translateY(1px); }
    @media (max-width: 820px) { .controls { display: flex; } }

    /* Test overlay */
    .test { position: absolute; top: 8px; left: 8px; background: #111; color:#fff; border-radius: 10px; padding: 8px 10px; font: 12px/1.3 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space: pre; pointer-events:none; opacity:.92; display:none; }
    .test.ok { background:#0a7a2f; }
    .test.fail { background:#9b1c1c; }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="960" height="270" aria-label="Chrome Dino Clone Game"></canvas>
    <div class="hud" aria-hidden="true">
      <div class="score" id="score">00000 <small id="hiscore">HI 00000</small></div>
      <div class="banner" id="banner">
        <div class="card">
          <h1>크롬 다이노 🦖</h1>
          <p>스페이스/↑: 점프 · ↓: 숙이기 · P: 일시정지 · R: 재시작</p>
          <p style="margin-top:8px;color:#888">모바일은 아래 버튼 사용 · 캔버스 탭으로 시작</p>
        </div>
      </div>
      <div class="hint">H: 히트박스 · O: 테스트 로그 보기</div>
      <div class="test" id="test"></div>
    </div>
    <div class="controls">
      <button id="jumpBtn" type="button">점프</button>
      <button id="duckBtn" type="button">숙이기</button>
    </div>
  </div>

  <script>
  // Chrome Dino minimal clone with robust short/long jump and built-in self-tests.
  (() => {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;

    const scoreEl = document.getElementById('score');
    const hiEl = document.getElementById('hiscore');
    const banner = document.getElementById('banner');
    const testEl = document.getElementById('test');

    // Logical size (fixed). Display scales via CSS.
    const W = canvas.width;  // 960
    const H = canvas.height; // 270

    // Ground line
    const GROUND_Y = Math.floor(H * 0.78); // ~210

    // Physics tuned: short tap should hop low, long hold should clear tall cactus
    const PHY = {
      gravity: 0.62,   // normal gravity when not holding jump
      lowGrav: 0.22,   // reduced gravity while holding (longer hang)
      minJumpVy: -10.6,// initial upward velocity (more negative = higher)
      jumpCutVy: -3.0, // if key released while rising, cap upward speed to this
      holdTime: 240    // ms window where lowGrav applies
    };

    // Game state
    let state = 'ready'; // 'ready' | 'running' | 'gameover' | 'paused'
    let last = performance.now();
    let time = 0;
    let showHit = false;

    // Speed & difficulty
    let baseSpeed = 6;
    let speed = baseSpeed;
    let distance = 0; // for score
    let score = 0;
    let hi = Number(localStorage.getItem('dino.hi') || 0);

    // Input
    const keys = new Set();
    let jumpHeldMs = 0; // 0=not holding; increases while held up to holdTime

    // Entities
    const clouds = [];
    const groundSegs = [];
    const obstacles = [];

    // Dino
    const dino = {
      x: 64,
      y: 0, // top-left y, computed from ground
      w: 46,
      h: 50,
      vy: 0,
      onGround: true,
      duck: false,
      anim: 0,
    };

    function reset() {
      state = 'ready';
      banner.style.display = '';
      time = 0; speed = baseSpeed; distance = 0; score = 0; jumpHeldMs = 0;
      obstacles.length = 0; clouds.length = 0; groundSegs.length = 0;
      dino.w = 46; dino.h = 50; dino.vy = 0; dino.onGround = true; dino.duck = false;
      dino.y = GROUND_Y - dino.h;
      // Clouds
      for (let i = 0; i < 4; i++) {
        clouds.push({ x: Math.random() * W, y: 20 + Math.random()*80, s: 0.2 + Math.random()*0.5 });
      }
      // Ground segments (repeat pattern)
      for (let x = 0; x < W + 200; x += 40) {
        groundSegs.push({ x, y: GROUND_Y + (Math.random() < 0.05 ? 1 : 0) });
      }
      // First obstacle a bit later
      nextSpawn = 1000;
      dayNight.t = 0; dayNight.isNight = false;
    }

    // Day/Night cycle
    const dayNight = { t: 0, isNight: false };

    function toggleDayNight() {
      dayNight.isNight = !dayNight.isNight;
      document.documentElement.style.setProperty('--bg', dayNight.isNight ? '#0c0f14' : '#f7f7f7');
      document.documentElement.style.setProperty('--fg', dayNight.isNight ? '#f0f6ff' : '#222');
    }

    function randInt(a, b) { return (a + Math.floor(Math.random() * (b - a + 1))); }

    function spawnObstacle() {
      // Choose cactus or ptero based on speed
      const usePtero = speed > 9 && Math.random() < 0.35;
      if (usePtero) {
        const y = [GROUND_Y - 100, GROUND_Y - 70, GROUND_Y - 40][randInt(0,2)];
        obstacles.push({ kind: 'p', x: W + 40, y, w: 52, h: 36, flap: 0 });
      } else {
        const kind = randInt(0,2); // 0 small, 1 medium, 2 tall
        const w = [18, 26, 34][kind];
        const h = [38, 50, 64][kind];
        const count = Math.random() < 0.10 ? 2 : 1; // double cactus sometimes
        const gap = randInt(36, 50);
        for (let i = 0; i < count; i++) {
          obstacles.push({ kind: 'c', x: W + 40 + i*(w+gap), y: GROUND_Y - h, w, h });
        }
      }
    }

    let nextSpawn = 800; // ms until next spawn

    function update(dt) {
      if (state !== 'running') return;
      time += dt;
      // Speed increases slowly with score
      speed = baseSpeed + Math.min(6, score / 250);

      // Score increases with time & speed (roughly 5–8 pts/sec)
      distance += dt * speed * 60; // frame-rate independent distance
      score = Math.floor(distance * 0.08);
      scoreEl.firstChild.nodeValue = String(score).padStart(5, '0');
      hiEl.textContent = 'HI ' + String(Math.max(hi, score)).padStart(5, '0');

      // Day/Night toggle every ~1500 score
      dayNight.t += dt * speed;
      if (score > 0 && score % 1500 === 0 && Math.floor((score-1)/1500) !== Math.floor(score/1500)) {
        toggleDayNight();
      }

      // Clouds drift
      for (const c of clouds) {
        c.x -= (0.3 + c.s) * dt * 60;
        if (c.x < -60) { c.x = W + Math.random()*120; c.y = 20 + Math.random()*80; c.s = 0.2 + Math.random()*0.5; }
      }

      // Ground scroll
      for (const g of groundSegs) {
        g.x -= speed * dt * 60;
        if (g.x < -40) { g.x += W + 80; g.y = GROUND_Y + (Math.random() < 0.05 ? 1 : 0); }
      }

      // Spawn logic
      nextSpawn -= dt*1000;
      if (nextSpawn <= 0) {
        spawnObstacle();
        const minGap = Math.max(900 - speed*25, 700); // ms (easier)
        const maxGap = Math.max(1500 - speed*15, 1000);
        nextSpawn = randInt(minGap, maxGap);
      }

      // Obstacles move
      for (const ob of obstacles) {
        ob.x -= speed * dt * 60;
        if (ob.kind === 'p') ob.flap += dt * 10;
      }
      while (obstacles.length && obstacles[0].x + obstacles[0].w < -8) obstacles.shift();

      // Dino physics
      // Apply gravity (variable while jump held)
      dino.vy += (dino.onGround ? 0 : (jumpHeldMs > 0 && jumpHeldMs < PHY.holdTime ? PHY.lowGrav : PHY.gravity)) * 60 * dt;
      dino.y += dino.vy * dt * 60;
      if (dino.y >= GROUND_Y - dino.h) {
        dino.y = GROUND_Y - dino.h; dino.vy = 0; if (!dino.onGround) jumpHeldMs = 0; dino.onGround = true;
      } else {
        dino.onGround = false;
      }

      // Ducking changes hitbox height
      if (dino.duck && dino.onGround) dino.h = 34; else dino.h = 50;
      if (dino.onGround) dino.y = GROUND_Y - dino.h;

      // Run animation
      if (dino.onGround) dino.anim += dt * (speed*0.5);

      // Collisions (AABB)
      for (const ob of obstacles) {
        const ax = dino.x + 6; const ay = dino.y + 4; const aw = dino.w - 12; const ah = dino.h - 8;
        const bx = ob.x; const by = ob.y; const bw = ob.w; const bh = ob.h;
        if (ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by) {
          gameOver();
          break;
        }
      }
    }

    function draw() {
      // Clear
      ctx.fillStyle = dayNight.isNight ? '#0c0f14' : '#ffffff';
      ctx.fillRect(0, 0, W, H);

      // Background sun/moon
      ctx.save();
      ctx.globalAlpha = 0.08;
      ctx.fillStyle = dayNight.isNight ? '#cde0ff' : '#ffbf47';
      ctx.beginPath(); ctx.arc(60, 46, 18, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      // Clouds
      ctx.fillStyle = dayNight.isNight ? '#c6d4e7' : '#d0d0d0';
      for (const c of clouds) drawCloud(c.x, c.y, 22);

      // Ground line & pebbles
      ctx.strokeStyle = dayNight.isNight ? '#6b7280' : '#9e9e9e';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(0, GROUND_Y+1); ctx.lineTo(W, GROUND_Y+1); ctx.stroke();
      ctx.fillStyle = dayNight.isNight ? '#4b5563' : '#bdbdbd';
      for (const g of groundSegs) ctx.fillRect(g.x, g.y+2, 18, 2);

      // Obstacles
      for (const ob of obstacles) {
        if (ob.kind === 'c') drawCactus(ob.x, ob.y, ob.w, ob.h);
        else drawPtero(ob.x, ob.y, ob.w, ob.h, ob.flap);
        if (showHit) drawHitbox(ob.x, ob.y, ob.w, ob.h);
      }

      // Dino
      drawDino(dino);
      if (showHit) drawHitbox(dino.x+6, dino.y+4, dino.w-12, dino.h-8);
    }

    function drawCloud(x, y, r) {
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.arc(x+20, y-8, r*0.8, 0, Math.PI*2);
      ctx.arc(x-18, y-6, r*0.7, 0, Math.PI*2);
      ctx.fill();
    }

    function drawCactus(x, y, w, h) {
      ctx.fillStyle = dayNight.isNight ? '#8cc08c' : '#2f7d32';
      ctx.fillRect(Math.floor(x), Math.floor(y), w, h);
      // arms
      ctx.fillRect(Math.floor(x - w*0.4), Math.floor(y + h*0.35), Math.floor(w*0.4), Math.floor(h*0.18));
      ctx.fillRect(Math.floor(x + w), Math.floor(y + h*0.5), Math.floor(w*0.4), Math.floor(h*0.18));
    }

    function drawPtero(x, y, w, h, flap) {
      const midY = y + h*0.5;
      ctx.fillStyle = dayNight.isNight ? '#e5e7eb' : '#333';
      ctx.beginPath();
      ctx.moveTo(x, midY);
      ctx.lineTo(x + w*0.4, y + (Math.sin(flap)*6));
      ctx.lineTo(x + w, midY);
      ctx.lineTo(x + w*0.6, y + h);
      ctx.closePath();
      ctx.fill();
      // head
      ctx.fillRect(x-8, midY-6, 10, 10);
    }

    function drawDino(d) {
      const leg = Math.floor(d.anim)%2;
      const color = dayNight.isNight ? '#e5e7eb' : '#222';
      ctx.fillStyle = color;
      // body
      ctx.fillRect(d.x, d.y+6, 40, 30);
      // head
      ctx.fillRect(d.x+28, d.y-4, 24, 20);
      // tail
      ctx.fillRect(d.x-8, d.y+18, 10, 8);
      // legs
      if (d.onGround && !d.duck) {
        ctx.fillRect(d.x+6, d.y+36, 10, 14);
        ctx.fillRect(d.x+24, d.y+36, 10, 14);
        if (leg===0) ctx.clearRect(d.x+6, d.y+36, 10, 6); else ctx.clearRect(d.x+24, d.y+36, 10, 6);
      } else if (d.duck && d.onGround) {
        // squat shape
        ctx.fillRect(d.x+10, d.y+24, 32, 18);
      } else {
        // in air
        ctx.fillRect(d.x+10, d.y+38, 24, 10);
      }
      // eye
      ctx.fillStyle = dayNight.isNight ? '#0c0f14' : '#fff';
      ctx.fillRect(d.x+44, d.y+2, 4, 4);
      ctx.fillStyle = color;
      ctx.fillRect(d.x+46, d.y+4, 2, 2);
    }

    function drawHitbox(x,y,w,h) {
      ctx.save();
      ctx.globalAlpha = 0.3; ctx.fillStyle = '#ef4444';
      ctx.fillRect(Math.floor(x), Math.floor(y), Math.floor(w), Math.floor(h));
      ctx.restore();
    }

    function gameOver() {
      state = 'gameover';
      banner.style.display = '';
      if (score > hi) { hi = score; localStorage.setItem('dino.hi', String(hi)); }
      showCenterMessage('Game Over', 'R: 재시작 · 스페이스: 다시 시작');
    }

    function startGame() {
      if (state === 'running') return;
      banner.style.display = 'none';
      if (state === 'gameover') reset();
      state = 'running';
    }

    function showCenterMessage(title, sub) {
      banner.innerHTML = `<div class="card"><h1>${title}</h1><p>${sub}</p></div>`;
    }

    function jump() {
      if (state === 'ready') startGame();
      if (state !== 'running') return;
      if (dino.onGround) {
        dino.vy = PHY.minJumpVy; dino.onGround = false; jumpHeldMs = 1; // enable variable jump window
      }
    }

    function duck(on) {
      if (state !== 'running') return;
      dino.duck = on;
    }

    function jumpCut(){
      if (state !== 'running') return;
      if (!dino.onGround){
        if (dino.vy < PHY.jumpCutVy) dino.vy = PHY.jumpCutVy;
        jumpHeldMs = PHY.holdTime;
      }
    }

    // Input handlers
    window.addEventListener('keydown', (e) => {
      if (['Space','ArrowUp','ArrowDown','KeyP','KeyH','KeyR','KeyO'].includes(e.code)) e.preventDefault();
      if (e.code === 'Space' || e.code === 'ArrowUp') { if (!keys.has('jump')) jump(); keys.add('jump'); }
      if (e.code === 'ArrowDown') { duck(true); keys.add('duck'); }
      if (e.code === 'KeyP') { if (state==='running'){ state='paused'; showCenterMessage('일시정지', 'P: 계속 · R: 재시작'); banner.style.display=''; } else if (state==='paused'){ state='running'; banner.style.display='none'; } }
      if (e.code === 'KeyH') { showHit = !showHit; }
      if (e.code === 'KeyR') { reset(); showCenterMessage('준비', '스페이스/↑: 시작'); }
      if (e.code === 'KeyO') { toggleTests(); }
    });
    window.addEventListener('keyup', (e) => {
      if (e.code === 'Space' || e.code === 'ArrowUp') {
        keys.delete('jump');
        // Jump cut: if key released while moving upward, cap upward velocity for short hop
        if (dino.vy < PHY.jumpCutVy) dino.vy = PHY.jumpCutVy;
        jumpHeldMs = PHY.holdTime;
      }
      if (e.code === 'ArrowDown') { keys.delete('duck'); duck(false); }
    });

    // Click / touch on canvas to jump
    canvas.addEventListener('mousedown', () => jump());
    canvas.addEventListener('mouseup', () => jumpCut());
    canvas.addEventListener('touchstart', (e) => { jump(); e.preventDefault(); }, { passive:false });
    canvas.addEventListener('touchend', () => jumpCut(), { passive:true });

    // On-screen buttons (mobile)
    const jumpBtn = document.getElementById('jumpBtn');
    const duckBtn = document.getElementById('duckBtn');
    jumpBtn.addEventListener('pointerdown', () => jump());
    jumpBtn.addEventListener('pointerup',   () => jumpCut());
    jumpBtn.addEventListener('pointercancel', () => jumpCut());
    duckBtn.addEventListener('pointerdown', () => duck(true));
    duckBtn.addEventListener('pointerup',   () => duck(false));
    duckBtn.addEventListener('pointercancel', () => duck(false));

    // Main loop
    function loop(now) {
      const dt = Math.min(0.05, (now - last) / 1000); // cap 50ms
      last = now;
      if (state === 'running') {
        if (keys.has('jump') && !dino.onGround && jumpHeldMs > 0 && jumpHeldMs < PHY.holdTime) {
          jumpHeldMs += dt*1000; // extend variable jump window while held
        }
        update(dt);
      }
      draw();
      requestAnimationFrame(loop);
    }

    reset();
    showCenterMessage('시작하려면 스페이스/↑ 또는 탭', '장애물을 피해 최대 점수를 노리세요');
    requestAnimationFrame((t)=>{ last = t; loop(t); });

    // -------------------
    // Built-in Test Suite
    // -------------------
    function toggleTests(){
      testEl.style.display = testEl.style.display === 'none' ? 'block' : 'none';
    }

    function runTests() {
      const out = [];
      let fails = 0;
      function test(name, fn){
        try { const ok = fn(); out.push((ok? '✔':'✘') + ' ' + name); if(!ok) fails++; }
        catch(e){ out.push('✘ ' + name + ' — ERR: ' + e.message); fails++; }
      }
      // Test 1: No stray $1 symbol (previous bug)
      test('no stray $1 reference', () => typeof $1 === 'undefined');

      // Prepare runnable state
      const prevState = state;
      state = 'running';
      reset();
      state = 'running';

      // Test 2: Jump sets initial velocity to PHY.minJumpVy
      test('jump() sets vy to minJumpVy', () => {
        const before = dino.vy; const wasGround = dino.onGround; jump();
        return wasGround && dino.vy === PHY.minJumpVy && !dino.onGround;
      });

      // Test 3: jumpCut() caps upward speed for short hop
      test('jumpCut() caps vy to jumpCutVy when rising', () => {
        // Simulate being mid-air rising fast
        dino.onGround = false; dino.vy = -12;
        jumpCut();
        return dino.vy >= PHY.jumpCutVy - 1e-6 && dino.vy <= PHY.jumpCutVy + 1e-6;
      });

      // Test 4: spawnObstacle() appends at least one obstacle
      test('spawnObstacle() creates obstacle(s)', () => {
        const n0 = obstacles.length; spawnObstacle(); return obstacles.length > n0;
      });

      // Test 5: Holding jump reduces gravity (more hang time)
      test('holding jump uses lowGrav', () => {
        dino.onGround = false; dino.vy = -6; jumpHeldMs = 1; const vy0 = dino.vy;
        // simulate two frames: lowGrav should increase vy slower than gravity
        const vyLow = vyAfter(0.016, true);
        dino.vy = vy0; const vyHigh = vyAfter(0.016, false);
        return (vyLow - vy0) < (vyHigh - vy0);
      });

      function vyAfter(dt, holding){
        const g = holding ? PHY.lowGrav : PHY.gravity; return dino.vy + g * 60 * dt;
      }

      // Output
      if (fails === 0) {
        testEl.className = 'test ok';
      } else {
        testEl.className = 'test fail';
      }
      testEl.textContent = out.join('\n');
      testEl.style.display = (location.hash === '#test') ? 'block' : 'none';
      if (location.hash === '#test') console.log(out.join('\n'));
      // Restore state
      state = prevState;
    }

    // Run tests once on load; show if #test present or toggle with O
    runTests();

  })();
  </script>
</body>
</html>
