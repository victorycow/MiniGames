<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>2048 Clone</title>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Pretendard:wght@400;600;800&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#0b0f19;         /* page background */
      --fg:#e5e7eb;         /* text */
      --muted:#9aa4b2;      /* secondary text */
      --panel:#0e1422;      /* card background */
      --ring:rgba(255,255,255,.08);
      --gap:10px;           /* grid gap */
      --tile:84px;          /* base tile size */
      --radius:14px;        /* border radius */
      --shadow: 0 1px 0 rgba(255,255,255,.04) inset, 0 20px 60px rgba(0,0,0,.45);
    }
    @media (max-width:480px){
      :root{ --tile:70px; --gap:8px; --radius:12px; }
    }

    html,body{height:100%;}
    body{
      margin:0; background:radial-gradient(1200px 600px at 20% -10%, #232a49 0%, rgba(35,42,73,0) 50%), var(--bg);
      color:var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Apple SD Gothic Neo", "Malgun Gothic", Pretendard, sans-serif;
      -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
      display:grid; place-items:center;
    }

    .wrap{width:100%; max-width:min(100vw, 560px); padding:24px; box-sizing:border-box;}
    .top{ display:grid; grid-template-columns:1fr auto; gap:12px; align-items:end; margin-bottom:16px; }
    .title{font-weight:800; font-size:32px; letter-spacing:.2px;}
    .subtitle{color:var(--muted); font-size:13px;}
    .panel{background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,0)); border:1px solid var(--ring); border-radius:var(--radius); padding:10px 12px; box-shadow:var(--shadow);}    
    .stats{display:flex; gap:10px;}
    .stat{display:grid; grid-template-rows:auto auto; align-items:center; justify-items:center; min-width:92px;}
    .stat .label{font-size:11px; color:var(--muted);}    
    .stat .value{font-weight:800; font-size:22px;}

    .btns{display:flex; gap:10px;}
    .btn{
      background:linear-gradient(180deg, #2a3358, #202743);
      color:#e9ecf8; border:1px solid var(--ring); border-radius:12px; padding:10px 14px; font-weight:700; font-size:14px; cursor:pointer;
      box-shadow:var(--shadow); transition:transform .05s ease, filter .15s ease; user-select:none;
    }
    .btn:hover{filter:brightness(1.08)}
    .btn:active{transform:translateY(1px)}
    .btn.secondary{background:linear-gradient(180deg, #1b213c, #151a30); font-weight:600;}

    /* BOARD */
    .board-wrap{position:relative; margin-top:12px;}
    .board{position:relative; background:#111733; border:1px solid var(--ring); border-radius:calc(var(--radius) + 4px); padding:var(--gap); box-shadow:var(--shadow); touch-action:none;}
    /* grid background cells */
    .grid{position:relative; display:grid; grid-template-columns:repeat(4, var(--tile)); grid-template-rows:repeat(4, var(--tile)); gap:var(--gap);} 
    .cell{background:rgba(255,255,255,.04); border-radius:12px;}
    /* tile layer */
    .tiles{position:absolute; inset:var(--gap); width:calc(4*var(--tile) + 3*var(--gap)); height:calc(4*var(--tile) + 3*var(--gap));}
    .tile{position:absolute; width:var(--tile); height:var(--tile); border-radius:12px; display:grid; place-items:center; font-weight:800; font-size:28px; color:#1b213a;
      transform:translate(var(--x), var(--y)); transition:transform 90ms ease-in; will-change:transform, filter;
      box-shadow: 0 8px 16px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.06);
    }
    .tile.small{font-size:24px}
    .tile.tiny{font-size:20px}
    .tile span{filter:drop-shadow(0 1px 0 rgba(255,255,255,.15));}

    /* tile colors */
    .v-2   { background:#e8f0ff; }
    .v-4   { background:#d6e3ff; }
    .v-8   { background:#c1d4ff; color:#0b1231; }
    .v-16  { background:#a7c0ff; color:#0b1231; }
    .v-32  { background:#8dacff; color:#0b1231; }
    .v-64  { background:#7398ff; color:#0b1231; }
    .v-128 { background:#5e85ff; color:#0b1231; }
    .v-256 { background:#4a70ff; color:#eef3ff; }
    .v-512 { background:#375bff; color:#eef3ff; }
    .v-1024{ background:#2848f0; color:#eef3ff; }
    .v-2048{ background:#1b38cc; color:#f2f6ff; }
    .v-4096{ background:#152ea5; color:#f2f6ff; }

    /* animations */
    .spawn{animation:pop .14s ease-out;}
    @keyframes pop{ 0%{ transform:translate(var(--x), var(--y)) scale(.6); filter:brightness(1.2);} 100%{ transform:translate(var(--x), var(--y)) scale(1);} }
    .merge{animation:thump .12s ease-in-out;}
    @keyframes thump{ 0%{ transform:translate(var(--x), var(--y)) scale(1.05);} 100%{ transform:translate(var(--x), var(--y)) scale(1);} }

    .hint{margin-top:10px; color:var(--muted); font-size:13px}

    /* OVERLAY */
    .overlay{position:absolute; inset:0; display:none; place-items:center; backdrop-filter: blur(6px);} 
    .overlay.show{display:grid}
    .dialog{background:linear-gradient(180deg, rgba(255,255,255,.1), rgba(255,255,255,.02)); border:1px solid var(--ring); border-radius:16px; padding:18px; text-align:center; box-shadow:var(--shadow)}
    .dialog h2{margin:0 0 6px 0}
    .dialog p{margin:0 0 14px 0; color:var(--muted)}

    /* accessibility helpers */
    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div>
        <div class="title">2048</div>
        <div class="subtitle">방향키 / 스와이프로 타일을 합쳐 점수를 올리세요. 2048을 만들면 승리!</div>
      </div>
      <div class="stats">
        <div class="panel stat" aria-live="polite" aria-atomic="true">
          <div class="label">점수</div>
          <div id="score" class="value">0</div>
        </div>
        <div class="panel stat" aria-live="polite" aria-atomic="true">
          <div class="label">최고</div>
          <div id="best" class="value">0</div>
        </div>
      </div>
    </div>

    <div class="btns" style="margin-bottom:8px">
      <button id="newGame" class="btn" aria-label="새 게임">새 게임</button>
      <button id="undo" class="btn secondary" aria-label="되돌리기(한 번)">되돌리기</button>
    </div>

    <div class="board-wrap">
      <div id="board" class="board" role="application" aria-label="2048 게임판" aria-live="polite">
        <div class="grid" aria-hidden="true">
          <!-- background cells -->
          <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
          <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
          <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
          <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
        </div>
        <div id="tiles" class="tiles"></div>
        <div id="overlay" class="overlay" aria-hidden="true">
          <div class="dialog">
            <h2 id="ovTitle">게임 종료</h2>
            <p id="ovDesc">새 게임으로 다시 도전하세요.</p>
            <div class="btns" style="justify-content:center">
              <button id="continueBtn" class="btn secondary">계속하기</button>
              <button id="restartBtn" class="btn">새 게임</button>
            </div>
          </div>
        </div>
      </div>
      <div class="hint">키보드: ↑↓←→ / WASD / HJKL • 모바일: 스와이프</div>
      <div class="sr-only" id="live" aria-live="polite" aria-atomic="true"></div>
    </div>
  </div>

<script>
(function(){
  const SIZE = 4;
  const PROB_4 = 0.1; // 10% 확률로 4 생성
  const tilesEl = document.getElementById('tiles');
  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const liveEl  = document.getElementById('live');
  const overlay = document.getElementById('overlay');
  const ovTitle = document.getElementById('ovTitle');
  const ovDesc  = document.getElementById('ovDesc');
  const restartBtn = document.getElementById('restartBtn');
  const continueBtn = document.getElementById('continueBtn');

  const $ = (sel)=>document.querySelector(sel);
  const boardEl = $('#board');
  const newGameBtn = $('#newGame');
  const undoBtn = $('#undo');

  let idSeq = 1;
  const nextId = ()=>idSeq++;

  function emptyGrid(){
    const g = new Array(SIZE);
    for(let r=0;r<SIZE;r++){ g[r] = new Array(SIZE).fill(null); }
    return g;
  }

  function cloneGrid(g){ return g.map(row=>row.slice()); }

  function randChoice(arr){ return arr[(Math.random()*arr.length)|0]; }

  function formatPos(r, c){
    const cs = getComputedStyle(document.documentElement);
    const gap = cs.getPropertyValue('--gap').trim();
    const tile = cs.getPropertyValue('--tile').trim();
    // [x, y] in CSS calc units
    return [
      `calc(${c} * (${tile} + ${gap}))`,
      `calc(${r} * (${tile} + ${gap}))`
    ];
  }

  // Tile class (simple POJO)
  function makeTile(value, r, c, opts={}){
    return {
      id: nextId(), value, r, c, prevR:null, prevC:null, mergedFrom:null, isNew: !!opts.isNew
    };
  }

  // Game state
  const game = {
    grid: emptyGrid(),
    tiles: [],
    score: 0,
    best: parseInt(localStorage.getItem('best2048')||'0',10),
    over:false,
    won:false,
    keepPlaying:false,
    // undo buffer
    undoState:null,
  };

  bestEl.textContent = game.best;

  function reset(){
    game.grid = emptyGrid();
    game.tiles = [];
    game.score = 0; updateScore(0);
    game.over=false; game.won=false; game.keepPlaying=false;
    game.undoState=null;
    idSeq = 1;
    tilesEl.innerHTML='';
    addRandomTile(); addRandomTile();
    render(true);
    hideOverlay();
  }

  function saveUndo(){
    game.undoState = {
      grid: cloneGrid(game.grid),
      tiles: game.tiles.map(t=>({...t})),
      score: game.score,
      over: game.over,
      won: game.won,
      keepPlaying: game.keepPlaying,
      idSeq
    };
  }

  function undo(){
    if(!game.undoState) return;
    const s = game.undoState;
    game.grid = cloneGrid(s.grid);
    game.tiles = s.tiles.map(t=>({...t}));
    game.score = s.score; updateScore(0,true);
    game.over = s.over; game.won = s.won; game.keepPlaying = s.keepPlaying;
    idSeq = s.idSeq;
    render(true);
  }

  function updateScore(delta, setExact){
    if(setExact){ scoreEl.textContent = game.score; return; }
    game.score += delta;
    scoreEl.textContent = game.score;
    if(game.score > game.best){ game.best = game.score; localStorage.setItem('best2048', String(game.best)); bestEl.textContent = game.best; }
  }

  function availableCells(){
    const cells=[];
    for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) if(!game.grid[r][c]) cells.push({r,c});
    return cells;
  }

  function addRandomTile(){
    const cells = availableCells();
    if(cells.length===0) return false;
    const {r,c} = randChoice(cells);
    const value = Math.random() < PROB_4 ? 4 : 2;
    const t = makeTile(value, r, c, {isNew:true});
    game.grid[r][c] = t; game.tiles.push(t);
    return true;
  }

  function withinBounds(r,c){ return r>=0 && r<SIZE && c>=0 && c<SIZE; }

  function cellAvailable(r,c){ return withinBounds(r,c) && !game.grid[r][c]; }

  function cellOccupiedBySame(r,c,val){ return withinBounds(r,c) && game.grid[r][c] && game.grid[r][c].value===val && !game.grid[r][c].mergedFrom; }

  const vectors = {
    up:    {r:-1, c:0},
    down:  {r:1,  c:0},
    left:  {r:0,  c:-1},
    right: {r:0,  c:1}
  };

  function buildTraversals(dir){
    const tr = { rows:[0,1,2,3], cols:[0,1,2,3] };
    if(dir==='right') tr.cols = tr.cols.slice().reverse();
    if(dir==='down')  tr.rows = tr.rows.slice().reverse();
    return tr;
  }

  function findFarthest(r,c, vec){
    let pr=r, pc=c; let nr=r+vec.r, nc=c+vec.c;
    while(withinBounds(nr,nc) && !game.grid[nr][nc]){ pr=nr; pc=nc; nr+=vec.r; nc+=vec.c; }
    return {farthestR:pr, farthestC:pc, nextR:nr, nextC:nc};
  }

  function move(dir){
    if(game.over) return;
    const vec = vectors[dir]; if(!vec) return;

    saveUndo();

    // reset merge flags and prev positions
    game.tiles.forEach(t=>{ t.mergedFrom=null; t.prevR = t.r; t.prevC = t.c; t.isNew=false; });

    let moved=false; let scoreGain=0;
    const tr = buildTraversals(dir);

    for(const r of tr.rows){
      for(const c of tr.cols){
        const tile = game.grid[r][c];
        if(!tile) continue;
        const {farthestR, farthestC, nextR, nextC} = findFarthest(r,c, vec);
        const next = withinBounds(nextR,nextC) ? game.grid[nextR][nextC] : null;

        if(next && next.value===tile.value && !next.mergedFrom){
          // merge into next cell
          const newVal = tile.value*2;
          const merged = makeTile(newVal, nextR, nextC);
          merged.mergedFrom = [tile, next];
          // place merged tile
          game.grid[nextR][nextC] = merged;
          // remove originals from grid
          game.grid[r][c] = null;
          const idxNext = game.tiles.indexOf(next);
          if(idxNext>-1) game.tiles.splice(idxNext,1);
          const idxTile = game.tiles.indexOf(tile);
          if(idxTile>-1) game.tiles.splice(idxTile,1);
          game.tiles.push(merged);
          scoreGain += newVal;
          moved = true;
          if(newVal===2048) game.won = true;
        }else{
          // move to farthest
          if(farthestR!==r || farthestC!==c){
            game.grid[r][c] = null;
            tile.r = farthestR; tile.c = farthestC;
            game.grid[farthestR][farthestC] = tile;
            moved = true;
          }
        }
      }
    }

    if(moved){
      updateScore(scoreGain);
      addRandomTile();
      render();
      if(!movesAvailable()) endGame();
      if(game.won && !game.keepPlaying) showWin();
    }else{
      // nothing moved: discard undo snapshot (no state change)
      game.undoState = null;
    }
  }

  function movesAvailable(){ return availableCells().length>0 || mergesAvailable(); }
  function mergesAvailable(){
    for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++){
      const t = game.grid[r][c]; if(!t) continue;
      for(const v of Object.values(vectors)){
        const nr=r+v.r, nc=c+v.c;
        if(withinBounds(nr,nc) && game.grid[nr][nc] && game.grid[nr][nc].value===t.value) return true;
      }
    }
    return false;
  }

  function endGame(){
    game.over = true;
    showOverlay('게임 종료', '더 이상 이동할 수 없습니다. 새 게임으로 다시 도전하세요.');
  }

  function showWin(){
    showOverlay('승리!', '2048을 달성했습니다. "계속하기"를 누르면 게임을 이어갈 수 있습니다.');
  }

  function showOverlay(title, desc){
    ovTitle.textContent = title; ovDesc.textContent = desc;
    overlay.classList.add('show'); overlay.setAttribute('aria-hidden','false');
  }
  function hideOverlay(){ overlay.classList.remove('show'); overlay.setAttribute('aria-hidden','true'); }

  continueBtn.addEventListener('click', ()=>{ hideOverlay(); game.keepPlaying = true; });
  restartBtn.addEventListener('click', ()=> reset());

  function render(hard){
    // clear and rebuild elements for simplicity and reliable animations
    tilesEl.innerHTML='';
    for(const t of game.tiles){
      const tileEl = document.createElement('div');
      tileEl.className = `tile v-${t.value} ${t.value>=1024?'tiny':t.value>=128?'small':''}`;
      const [x,y] = formatPos(t.r, t.c); // x uses column index, y uses row index
      tileEl.style.setProperty('--x', x);
      tileEl.style.setProperty('--y', y);
      tileEl.dataset.id = t.id;
      const span = document.createElement('span'); span.textContent = t.value; tileEl.appendChild(span);

      if(t.isNew){ tileEl.classList.add('spawn'); }
      if(t.mergedFrom){ tileEl.classList.add('merge'); }
      tilesEl.appendChild(tileEl);

      // if merged, show a brief overlayed merged tile animation
      if(t.mergedFrom){
        // also create ghost tiles from previous positions to visualize movement
        for(const src of t.mergedFrom){
          const ghost = document.createElement('div'); ghost.className = `tile v-${src.value}`; ghost.style.opacity = .65;
          const [gx,gy] = formatPos(src.r, src.c);
          ghost.style.setProperty('--x', gx); ghost.style.setProperty('--y', gy);
          const gspan = document.createElement('span'); gspan.textContent = src.value; ghost.appendChild(gspan);
          tilesEl.appendChild(ghost);
          requestAnimationFrame(()=>{
            // animate ghost to merged tile position then fade out
            ghost.style.transition = 'transform 90ms ease-in, opacity 120ms ease-out';
            ghost.style.setProperty('--x', x); ghost.style.setProperty('--y', y);
            ghost.style.opacity = 0;
            setTimeout(()=> ghost.remove(), 140);
          });
        }
      }
    }

    // live region for screen readers
    liveEl.textContent = `점수 ${game.score}. ${game.over? '게임 종료': game.won? '승리 가능, 계속 여부 선택' : ''}`;
  }

  // INPUTS
  const keyMap = {
    'ArrowUp':'up','KeyW':'up','KeyK':'up',
    'ArrowDown':'down','KeyS':'down','KeyJ':'down',
    'ArrowLeft':'left','KeyA':'left','KeyH':'left',
    'ArrowRight':'right','KeyD':'right','KeyL':'right'
  };
  window.addEventListener('keydown', (e)=>{
    const dir = keyMap[e.code];
    if(!dir) return;
    e.preventDefault();
    move(dir);
  }, {passive:false});

  // Touch swipe
  let touchStart=null;
  boardEl.addEventListener('touchstart', (e)=>{
    if(!e.touches[0]) return; touchStart = {x:e.touches[0].clientX, y:e.touches[0].clientY};
  }, {passive:true});
  boardEl.addEventListener('touchend', (e)=>{
    if(!touchStart) return;
    const dx = (e.changedTouches[0].clientX - touchStart.x);
    const dy = (e.changedTouches[0].clientY - touchStart.y);
    const absX = Math.abs(dx), absY = Math.abs(dy);
    const thresh = 20; // minimal swipe
    if(Math.max(absX,absY) < thresh){ touchStart=null; return; }
    if(absX > absY) move(dx>0?'right':'left'); else move(dy>0?'down':'up');
    touchStart=null;
  }, {passive:true});

  // Buttons
  newGameBtn.addEventListener('click', reset);
  undoBtn.addEventListener('click', ()=>{ undo(); });

  // INIT
  function setupBoardSize(){
    // set board pixel size based on CSS variables
    const s = getComputedStyle(document.documentElement);
    const tile = parseFloat(s.getPropertyValue('--tile'));
    const gap  = parseFloat(s.getPropertyValue('--gap'));
    const px = 4*tile + 5*gap; // 4 tiles + 5 gaps (outer padding counts as gap)
    const board = document.querySelector('.board');
    board.style.width = px + 'px';
    board.style.height = px + 'px';
  }
  window.addEventListener('resize', setupBoardSize);

  setupBoardSize();
  reset();

  // --- Self-tests (non-intrusive, console only) ---
  (function runSelfTests(){
    const results=[];
    const assert=(name,cond)=>results.push({test:name, pass:!!cond});

    // T1: formatPos returns [x,y] as strings including calc(
    const p = formatPos(1,2);
    assert('formatPos returns [x,y]', Array.isArray(p) && p.length===2 && p[0].includes('calc(') && p[1].includes('calc('));

    // T2: board initializes to 4x4 and starts with two tiles
    assert('grid is 4x4', game.grid.length===4 && game.grid.every(row=>row.length===4));
    assert('start has two tiles', game.tiles.length===2);

    // T3: addRandomTile works when space available
    const before = availableCells().length;
    const added = addRandomTile();
    assert('addRandomTile inserts a tile', added && availableCells().length===before-1);

    // T4: a movement call does not throw and maintains invariants
    const tilesBefore = game.tiles.length;
    try{ move('left'); assert('move("left") runs', true); }catch(e){ assert('move("left") runs', false); console.error(e); }
    const cellsCount = game.grid.flat().filter(Boolean).length;
    assert('tiles array matches grid count', cellsCount===game.tiles.length);

    console.table(results);
    const failed = results.filter(r=>!r.pass);
    if(failed.length){ console.warn('Self-tests failed:', failed); }
    // Clean state for user
    reset();
  })();
})();
</script>
</body>
</html>
